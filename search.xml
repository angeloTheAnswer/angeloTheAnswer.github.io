<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>maxProfit</title>
      <link href="/2021/09/07/maxprofit/"/>
      <url>/2021/09/07/maxprofit/</url>
      
        <content type="html"><![CDATA[<p><strong>题目:</strong><br><strong>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</strong><br><strong>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</strong><br><strong>返回 你能获得的 最大 利润 。</strong></p><p><em>思路：</em><br><em>交易者初始状态是持币未持股，所以一定是先买在卖，既然是先买在卖，那么要想收益，一定是后一日的股价大于前一日的股价</em><br><em>题意是求上升区间的高度和</em></p><pre class="line-numbers language-sh"><code class="language-sh">class Solution:    def maxProfit(self, prices: List[int]) -> int:        if len(prices) < 2:            return 0        sum = 0         for i in range(0,len(prices)-1):            if prices[i+1] - prices[i]>0:                temp = prices[i+1] - prices[i]                sum+=temp        return sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>边界说明：</strong><br><code>len(prices) < 2</code><br><em>因为买、卖后才能获利，所以prices的长度小于2无法获利</em><br><code>range(0,len(prices)-1)</code><br><em>由于要比较后一天i+1与当前一天的价格i,因此i+1要小于prices的长度</em></p><p><strong>TheAnswer</strong><br><em>运算符<code>+=</code>表示将运算符左边变量的内容与运算符右边变量的内容相加，并再次将结果存储到运算符左边的变量中</em></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Solution </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置多个git</title>
      <link href="/2021/08/11/pei-zhi-duo-ge-git/"/>
      <url>/2021/08/11/pei-zhi-duo-ge-git/</url>
      
        <content type="html"><![CDATA[<h4 id="生成SSH"><a href="#生成SSH" class="headerlink" title="生成SSH"></a>生成SSH</h4><p>第一个账号生成ssh key</p><pre class="line-numbers language-sh"><code class="language-sh">ssh-keygen -t rsa -C "your1@email.com"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二个账号生成ssh key</p><pre class="line-numbers language-sh"><code class="language-sh">ssh-keygen -t rsa -C "your2@email.com"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="部署SSH-KEY"><a href="#部署SSH-KEY" class="headerlink" title="部署SSH KEY"></a>部署SSH KEY</h4><p>在GitLab/GitHub上部署SSH KEY</p><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><p>新建config没有后缀名</p><h5 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h5><pre class="line-numbers language-sh"><code class="language-sh">Host    　　主机别名HostName　　服务器真实地址IdentityFile　　私钥文件路径PreferredAuthentications　　认证方式User　　用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="配置内容"><a href="#配置内容" class="headerlink" title="配置内容"></a>配置内容</h5><pre class="line-numbers language-sh"><code class="language-sh"># 别名可以随意写 服务器真实地址是ip就是ip 是域名就是域名# 配置Github账号Host user1.github.comHostName github.comIdentityFile C:\\Users\\TheAnswer\\.ssh\\id_rsaPreferredAuthentications publickeyUser user1# 配置GitLabHost xxxxHostName xx.xx.xx.xxIdentityFile C:\\Users\\TheAnswer\\.ssh\\id_rsa2PreferredAuthentications publickeyUser user2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest接口自动化框架搭建</title>
      <link href="/2021/06/13/pytest/"/>
      <url>/2021/06/13/pytest/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em>眼泪不是我们的答案。拼搏才是我们的选择</em></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Java环境 java version “1.8.0_271”<br>Python环境 3.7.9</p><h2 id="什么是自动化框架"><a href="#什么是自动化框架" class="headerlink" title="什么是自动化框架"></a>什么是自动化框架</h2><p>作用：<br>1、提高测试效率，减低维护成本<br>2、减少人工干预，提高测试准确性，增加代码重用性<br>3、核心思想是让不懂代码的人也能够通过这个框架去实现自动化</p><h2 id="Pytest特性"><a href="#Pytest特性" class="headerlink" title="Pytest特性"></a>Pytest特性</h2><p>1、比较灵活的单元测试框架<br>2、pytest可以和selenium、request、appiium结合实现web自动化、接口自动化、app自动化<br>3、pytest可以实现测试用例的跳过以及reruns失败用例重试<br>4、pytest可以和allure生成美观的测试报告<br>5、pytest可以和jenkins持续集成<br>6、pytest有很多非常强大的插件。并且这些插件能够实现很多实用的操作</p><h4 id="Pytest单元测试框架与自动化测试框架的关系"><a href="#Pytest单元测试框架与自动化测试框架的关系" class="headerlink" title="Pytest单元测试框架与自动化测试框架的关系"></a>Pytest单元测试框架与自动化测试框架的关系</h4><p>1、单元测试框架只是自动化测试框架的组成部分之一<br>2、pom设计模式只是自动化测试框架中的组成部分<br>3、数据驱动<br>4、关键字驱动<br>5、全局配置文件封装<br>6、日志监控<br>7、selenium，requests 二次封装<br>8、断言<br>9、报告邮件  </p><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><p>1、pytest：单元测试框架<br>2、pytest-html：生成HTML格式的报告<br>3、pytest-xdist：测试用例分布式执行，多CPU分发<br>4、pytest-ordering：用于改变测试用例的执行顺序<br>5、pytest-rerunfailfures：用例失败重跑<br>6、allure-pytest：用于生成美观的测试报告  </p><h5 id="常用插件批量安装"><a href="#常用插件批量安装" class="headerlink" title="常用插件批量安装"></a>常用插件批量安装</h5><p>步骤1、新建.txt文件<br>步骤2、把插件名放入文件中<br>步骤3、通过pip install -r 文件.txt完成安装<br>步骤4、验证是否安装成功 使用命令pytest –version  </p><h5 id="allure测试报告安装"><a href="#allure测试报告安装" class="headerlink" title="allure测试报告安装"></a>allure测试报告安装</h5><p>1、下载、解压<br>下载地址：<a href="https://github.com/allure-framework/allure2/" target="_blank" rel="noopener">https://github.com/allure-framework/allure2/</a>  releases<br>2、配置环境变量<br>在系统环境变量后追加解压路径 例如：E:\allure-2.13.7\bin<br>3、验证是否安装成功：<br>分别在dos和pycharm中验证    </p><pre class="line-numbers language-sh"><code class="language-sh">allure --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><em>注意：dos可以验证成功但是pycharm验证失败需重启pycharm</em></strong></p><h4 id="jpype测试报告安装"><a href="#jpype测试报告安装" class="headerlink" title="jpype测试报告安装"></a>jpype测试报告安装</h4><p><em>概述：JPype 是一个能够让 python 代码方便地调用 Java 代码的工具</em><br>1、下载whl包JPype1-1.1.2-cp37-cp37m-win32.whl<br>下载地址：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a><br>2、安装jpype<br>1)命令行进入whl包所在目录<br>2)执行安装命令  </p><pre class="line-numbers language-sh"><code class="language-sh">python -m pip install JPype1-1.1.2-cp37-cp37m-win32.whl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h2><h3 id="框架结构图"><a href="#框架结构图" class="headerlink" title="框架结构图"></a>框架结构图</h3><p><img src="jiagoutu.png" alt="目录结构"></p><h3 id="pytest-ini配置文件"><a href="#pytest-ini配置文件" class="headerlink" title="pytest.ini配置文件"></a>pytest.ini配置文件</h3><p>1、文件位置：一般放在根目录<br>2、文件编码：必须是ANSI，可以使用记事本修改编码格式<br>3、文件作用：改变pytest默认行为<br>4、不管是主函数的模式运行、命令行模式运行，都会去读取这个配置文件<br>5、配置文件</p><pre class="line-numbers language-sh"><code class="language-sh">[pytest]#命令行的参数，用空格分隔#addopts=-vs -k mingchen --alluredir ./temps --clean-alluredir# addopts=-vs ./testcase/test_rqu_mingchenapi.py --alluredir ./temps --clean-allurediraddopts=-vs ./testcase/test_api.py::TestApi::test_openapi_mingchen --alluredir ./temps --clean-alluredir#测试用例路径testpaths=testcase#模块名的规则python_files=test_*.py#类名的规则python_classes=Test*#方法名的规则python_functions=test#标记测试用例markers=    smoke1:冒烟用例1    smoke2:冒烟用例2    smoke3:冒烟用例3# 命令行窗口日志输出配置# log_cli 可以输入0, False 代码不输出日志， 1、True 代表开启日志输出# log_cli_level 代表日志输出级别# log_cli_date_format 日期格式# log_cli_format 日志模板格式log_cli=1log_cli_level=infolog_cli_date_format=%Y-%m-%d-%H-%M-%Slog_cli_format=%(asctime)s-%(filename)s-%(module)s-%(funcName)s-%(lineno)d-%(levelname)s-%(message)s#  日志输出到文件配置#  log_file 日志文件#  log_file_level 代表日志输出级别#  log_file_date_format 日期格式#  log_file_format 日志模板格式log_file=log/test.loglog_file_level=debuglog_file_date_format=%Y-%m-%d %H:%M:%Slog_file_format=%(asctime)s %(filename)s %(module)s %(funcName)s %(lineno)d %(levelname)s: %(message)s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="默认用例规则"><a href="#默认用例规则" class="headerlink" title="默认用例规则"></a>默认用例规则</h3><p>模块名必须以test_开头或者_test结尾<br>测试类必须以Test开头，并且不能有init方法<br>测试方法必须以test开头<br>以上规则可以在pytest.ini进行配置</p><pre class="line-numbers language-sh"><code class="language-sh">#模块名的规则python_files=test_*.py#类名的规则python_classes=Test*#方法名的规则python_functions=test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试用例运行方式"><a href="#测试用例运行方式" class="headerlink" title="测试用例运行方式"></a>测试用例运行方式</h3><h4 id="主函数模式"><a href="#主函数模式" class="headerlink" title="主函数模式"></a>主函数模式</h4><pre class="line-numbers language-sh"><code class="language-sh">#运行所有用例pytest.main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">#指定模块运行pytest.main(['-vs','test_modul1.py'])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">#指定目录运行pytest.main(['-vs','./list_testcase'])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过nodeid指定运行用例：nodeid由模块名，分隔符，类名，方法名，函数名组成</p><pre class="line-numbers language-sh"><code class="language-sh">#通过nodeid指定运行用例pytest.main(['-vs','./模块名/文件名::函数名'])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">#通过nodeid指定运行用例pytest.main(['-vs','./模块名/文件名::类名::方法名'])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>1、运行所有用例</p><pre class="line-numbers language-sh"><code class="language-sh">pytest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、指定模块运行</p><pre class="line-numbers language-sh"><code class="language-sh">pytest -vs test_modul.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、指定目录运行</p><pre class="line-numbers language-sh"><code class="language-sh">pytest -vs ./list_testcase<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、指定函数运行</p><pre class="line-numbers language-sh"><code class="language-sh">pytest -vs ./list_testcase/文件名::函数名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><em>小插曲：pytest命令参数</em></strong><br><strong><em>-s：表示输出调试信息</em></strong><br><strong><em>-v：显示更详细的信息</em></strong><br><strong><em>-vs：两个参数一起用</em></strong><br><strong><em>-n：支持多线程或者分布式运行测试用例</em></strong>  </p><pre class="line-numbers language-sh"><code class="language-sh">#多线程分布式执行用例pytest -vs ./list_testcase/testcase.py -n 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>–reruns NUM：失败用例重跑</em></strong><br><strong><em>-x：表示只要有一个用例报错，那么测试停止</em></strong><br><strong><em>–maxfail=2：比那时出现两个失败用例就停止</em></strong><br><strong><em>-k：根据测试用例的部分字符串来指定执行测试用例</em></strong>  </p><pre class="line-numbers language-sh"><code class="language-sh">#多线程分布式执行用例pytest -vs ./list_testcase/testcase.py -n 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>–html ./report/report.html：在指定目录下生成报告</em></strong>  </p><h4 id="通过读取pytest-ini配置文件执行"><a href="#通过读取pytest-ini配置文件执行" class="headerlink" title="通过读取pytest.ini配置文件执行"></a>通过读取pytest.ini配置文件执行</h4><pre class="line-numbers language-sh"><code class="language-sh">#pytest.ini配置文件执行用例addopts=-vs ./testcase/test_api.py::TestApi::test_case_api<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="创建一个通过配置文件执行的测试用例demo"><a href="#创建一个通过配置文件执行的测试用例demo" class="headerlink" title="创建一个通过配置文件执行的测试用例demo"></a>创建一个通过配置文件执行的测试用例demo</h3><p>1、创建一个文件名为api_automation<br>2、在api_automation目录下创建testcase文件夹<br>3、在testcase下创建test_demo.py</p><pre class="line-numbers language-sh"><code class="language-sh">[testcase/test_demo.py]class TestDemoClass:    def test_01_case1(self):        print('\n测试用例1')    def test_02_case2(self):        print('\n测试用例2')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、在api_automation目录下创建pytest.ini配置文件(注意编码格式)</p><pre class="line-numbers language-sh"><code class="language-sh">#命令行的参数，用空格分隔addopts=-vs ./testcase/test_demo.py::TestDemoClass::test_01_case1 #测试用例路径testpaths=testcase#模块名的规则python_files=test_*.py#类名的规则python_classes=Test*#方法名的规则python_functions=test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、在api_automation下创建run.py主函数</p><pre class="line-numbers language-sh"><code class="language-sh">import osimport timeimport pytestif __name__=='__main__':    pytest.main()    time.sleep(2)    #生成报告    # os.system('allure generate ./temps -o ./report --clean')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6、运行run.py</p><pre class="line-numbers language-sh"><code class="language-sh">[运行信息]======================================================= test session starts =======================================================platform win32 -- Python 3.7.9, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 -- D:\python\python.execachedir: .pytest_cachemetadata: {'Python': '3.7.9', 'Platform': 'Windows-10-10.0.19041-SP0', 'Packages': {'pytest': '6.2.4', 'py': '1.10.0', 'pluggy': '0.13.1'}, 'Plugins': {'allure-pytest': '2.9.45', 'forked': '1.4.0', 'html': '3.1.1', 'metadata': '2.0.1', 'ordering': '0.6', 'rerunfailures': '10.2', 'xdist': '2.5.0'}, 'JAVA_HOME': 'D:\\java\\jdk1.8'}rootdir: D:\work\repository\project\api_automation, configfile: pytest.iniplugins: allure-pytest-2.9.45, forked-1.4.0, html-3.1.1, metadata-2.0.1, ordering-0.6, rerunfailures-10.2, xdist-2.5.0collected 1 itemtestcase/test_demo.py::TestDemoClass::test_01_case1测试用例1PASSED======================================================== 1 passed in 0.11s ======================================================== <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试用例执行顺序"><a href="#测试用例执行顺序" class="headerlink" title="测试用例执行顺序"></a>测试用例执行顺序</h4><p>pytest默认从上到下<br>unitest以ascii的大小决定执行顺序</p><h5 id="pytest-改变默认执行顺序"><a href="#pytest-改变默认执行顺序" class="headerlink" title="pytest 改变默认执行顺序"></a>pytest 改变默认执行顺序</h5><p>使用mark标记</p><pre class="line-numbers language-sh"><code class="language-sh">[testcase/test_demo.py]class TestDemoClass:    def test_01_case1(self):        print('\n测试用例1')    @pytest.mark.run(roder=1)    def test_02_case2(self):        print('\n测试用例2')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="pytest-分组执行"><a href="#pytest-分组执行" class="headerlink" title="pytest 分组执行"></a>pytest 分组执行</h4><p>pytest进行分组测试的方法是使用装饰器 @pytest.mark.标记名称，被标记为相同名称的用例可以看做为同一个组。<br>分组执行可应用与冒烟用例执行、分模块执行、分接口和web执行。</p><h5 id="分组执行-冒烟用例"><a href="#分组执行-冒烟用例" class="headerlink" title="分组执行-冒烟用例"></a>分组执行-冒烟用例</h5><pre class="line-numbers language-sh"><code class="language-sh">[testcase/test_demo.py]class TestDemoClass:    @pytest.mark.smoke1    def test_01_case1(self):        print('\n测试用例1')    def test_02_case2(self):        print('\n测试用例2')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">[pytest.ini]#命令行的参数，用空格分隔addopts=-vs -m#测试用例路径testpaths=testcase#模块名的规则python_files=test_*.py#类名的规则python_classes=Test*#方法名的规则python_functions=test#标记测试用例markers=    smoke1:冒烟用例1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成配置后执行run.py即可</p><pre class="line-numbers language-sh"><code class="language-sh">[运行信息]========================================================================================= test session starts =========================================================================================platform win32 -- Python 3.7.9, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 -- D:\python\python.execachedir: .pytest_cachemetadata: {'Python': '3.7.9', 'Platform': 'Windows-10-10.0.19041-SP0', 'Packages': {'pytest': '6.2.4', 'py': '1.10.0', 'pluggy': '0.13.1'}, 'Plugins': {'allure-pytest': '2.9.45', 'forked': '1.4.0', 'html': '3.1.1', 'metadata': '2.0.1', 'ordering': '0.6', 'rerunfailures': '10.2', 'xdist': '2.5.0'}, 'JAVA_HOME': 'D:\\java\\jdk1.8'}rootdir: D:\work\repository\project\api_automation, configfile: pytest.ini, testpaths: testcaseplugins: allure-pytest-2.9.45, forked-1.4.0, html-3.1.1, metadata-2.0.1, ordering-0.6, rerunfailures-10.2, xdist-2.5.0collected 54 items / 53 deselected / 1 selectedtestcase/test_demo.py::TestDemoClass::test_01_case1测试用例1PASSED================================================================================== 1 passed, 53 deselected in 2.61s =================================================================================== <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="同一个用例标记多个组"><a href="#同一个用例标记多个组" class="headerlink" title="同一个用例标记多个组"></a>同一个用例标记多个组</h5><pre class="line-numbers language-sh"><code class="language-sh">[testcase/test_demo.py]class TestDemoClass:    @pytest.mark.smoke1    @pytest.mark.smoke2    def test_01_case1(self):        print('\n测试用例1')    def test_02_case2(self):        print('\n测试用例2')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">[pytest.ini]#命令行的参数，用空格分隔addopts=-vs -m#测试用例路径testpaths=testcase#模块名的规则python_files=test_*.py#类名的规则python_classes=Test*#方法名的规则python_functions=test#标记测试用例markers=    smoke1:冒烟用例1    smoke2:冒烟用例2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="分组执行支持逻辑运算符"><a href="#分组执行支持逻辑运算符" class="headerlink" title="分组执行支持逻辑运算符"></a>分组执行支持逻辑运算符</h5><p>1、or连接多个标记名称会执行包含这些标记的用例<br>2、and 连接多个标记名称会执行多个标记均存在的用例<br>3、not 连接多个标记名称会执行非这个标记的用例  </p><p>以or连接举例：  </p><pre class="line-numbers language-sh"><code class="language-sh">[testcase/test_demo.py]class TestDemoClass:    @pytest.mark.smoke1    def test_01_case1(self):        print('\n测试用例1')    @pytest.mark.smoke2    def test_02_case2(self):        print('\n测试用例2')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">[pytest.ini]#命令行的参数，用空格分隔addopts=-vs -m "smoke1 or smoke2"#测试用例路径testpaths=testcase#模块名的规则python_files=test_*.py#类名的规则python_classes=Test*#方法名的规则python_functions=test#标记测试用例markers=    smoke1:冒烟用例1    smoke2:冒烟用例2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">[运行信息]========================================================================================= test session starts =========================================================================================platform win32 -- Python 3.7.9, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 -- D:\python\python.execachedir: .pytest_cachemetadata: {'Python': '3.7.9', 'Platform': 'Windows-10-10.0.19041-SP0', 'Packages': {'pytest': '6.2.4', 'py': '1.10.0', 'pluggy': '0.13.1'}, 'Plugins': {'allure-pytest': '2.9.45', 'forked': '1.4.0', 'html': '3.1.1', 'metadata': '2.0.1', 'ordering': '0.6', 'rerunfailures': '10.2', 'xdist': '2.5.0'}, 'JAVA_HOME': 'D:\\java\\jdk1.8'}rootdir: D:\work\repository\project\api_automation, configfile: pytest.ini, testpaths: testcaseplugins: allure-pytest-2.9.45, forked-1.4.0, html-3.1.1, metadata-2.0.1, ordering-0.6, rerunfailures-10.2, xdist-2.5.0collected 54 items / 52 deselected / 2 selectedtestcase/test_demo.py::TestDemoClass::test_01_case1测试用例1PASSEDtestcase/test_demo.py::TestDemoClass::test_02_case2测试用例2PASSED================================================================================== 2 passed, 52 deselected in 2.54s ===================================================================================<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试用例跳过"><a href="#测试用例跳过" class="headerlink" title="测试用例跳过"></a>测试用例跳过</h4><h5 id="有条件跳过"><a href="#有条件跳过" class="headerlink" title="有条件跳过"></a>有条件跳过</h5><pre class="line-numbers language-sh"><code class="language-sh">@pytest.mark.skipif(条件参数>=条件,reason="原因")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="无条件跳过"><a href="#无条件跳过" class="headerlink" title="无条件跳过"></a>无条件跳过</h5><pre class="line-numbers language-sh"><code class="language-sh">@pytest.mark.skip(reason="原因")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Pytest-前后置处理-固件、夹具"><a href="#Pytest-前后置处理-固件、夹具" class="headerlink" title="Pytest 前后置处理(固件、夹具)"></a>Pytest 前后置处理(固件、夹具)</h4><h5 id="setup-teardown，setup-class-teardown-class"><a href="#setup-teardown，setup-class-teardown-class" class="headerlink" title="setup/teardown，setup_class/teardown_class"></a>setup/teardown，setup_class/teardown_class</h5><pre class="line-numbers language-sh"><code class="language-sh">class TestDemo:    #这个在所用用例之前执行一次    def setup_class(self):        print('\n在每个类执行之前的初始化操作：例如：创建日志对象、创建数据库连接、创建接口的请求对象')    #在每个用例之前执行一次    def setup(self):        print('\n在执行测试用之前初始化的代码：打开浏览器、加载网页')    def test_01(self):        print('\n测试用例1')    def test_02(self):        print('\n测试用例2')    def teardown(self):        print('\n在执行测试用例之后的扫尾的代码：关闭浏览器')    def teardown_class(self):        print('\n在每个类执行后的扫尾工作：比如：销毁日志对象、销毁数据库连接、销毁接口的请求对象')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="使用pytest-fixture-装饰器来实现部分用例的前后置"><a href="#使用pytest-fixture-装饰器来实现部分用例的前后置" class="headerlink" title="使用pytest.fixture()装饰器来实现部分用例的前后置"></a>使用pytest.fixture()装饰器来实现部分用例的前后置</h5><pre class="line-numbers language-sh"><code class="language-sh">@pytest.fixture(scope="",param="",autouse="",ids="",name="")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(1)scope表示的是被@pytest.fixture标记的方法的作用域，默认为function，还有class、module、package/session<br>(2)param：参数化（支持列表[]、元祖()、字典列表[{},{},{}]、字典元祖([],[],[])）<br>print(‘\n在每个类执行后的扫尾工作：比如：销毁日志对象、销毁数据库连接、销毁接口的请求对象’)<br>(3)autouse=True：自动使用默False<br>(4)ids：当使用param参数化时，给每个值设置一个变量名，意义不大<br>(5)name：表示的是给被@pytest.fixture标记的方法取一个别名，当取了别名之后原来的名称就用不了<br><strong><em>return和yield都是返回的意思但是return后面不能有代码，yield后面可以有代码</em></strong> </p><pre class="line-numbers language-sh"><code class="language-sh">import pytest@pytest.fixture(scope="function",param=['1','2','3'],ids=['a','b','c'])def my_fixture(request):    print('前置')    yield request.param    print('后置')class TestDemoClass:    def test_01_case1(self):        print('\n测试用例1')    def test_02_case2(self,my_fixture):        print('\n测试用例2')        print('------'+str(my_fixture))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">import pytest@pytest.fixture(scope="function",param=['1','2','3'],name='aaa')def my_fixture(request):    return request.paramclass TestDemoClass:    def test_01_case1(self):        print('\n测试用例1')    def test_02_case2(self,aaa):        print('\n测试用例2')        print('------'+str(aaa))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>assert</p>]]></content>
      
      
      <categories>
          
          <category> pytest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 自动化 </tag>
            
            <tag> pytest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>work</title>
      <link href="/2020/12/02/work/"/>
      <url>/2020/12/02/work/</url>
      
        <content type="html"><![CDATA[<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试</p>]]></content>
      
      
      
        <tags>
            
            <tag> problem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>removeDuplicates</title>
      <link href="/2020/12/01/removeduplicates/"/>
      <url>/2020/12/01/removeduplicates/</url>
      
        <content type="html"><![CDATA[<p><strong>题目:</strong><br><strong>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</strong><br><strong>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</strong><br><strong>将最终结果插入 nums 的前 k 个位置后返回 k 。</strong><br><strong>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 <code>O(1)</code> 额外空间的条件下完成。</strong></p><pre class="line-numbers language-sh"><code class="language-sh">class Solution(object):    def removeDuplicates(self,nums: List[int]) -> int:        for i in range(len(nums)-1,0,-1):            if nums[i] == nums[i-1]:                del(nums[i])        return len(nums)        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数中参数后面的冒号是参数的类型建议符<br>函数后面的箭头是函数返回值的类型建议符</p><p>python中的<code>range()</code>函数</p><p>range()函数用于生成一个整数序列</p><p>第一种只有一个参数<code>range(stop)</code></p><pre class="line-numbers language-sh"><code class="language-sh">#range(10)指的是默认从0开始，步长为1，不包括10print('示例结果：',list(range(10)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">示例结果： [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二种有两个参数<code>range(start,stop)</code></p><pre class="line-numbers language-sh"><code class="language-sh">#range(1,10)指的是1开始，步长为1，不包括10print('示例结果：',list(range(1,10)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">示例结果： [1, 2, 3, 4, 5, 6, 7, 8, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三种有三个参数<code>range(start,stop,step)</code></p><pre class="line-numbers language-sh"><code class="language-sh">#range(1,10,2)指的是1开始，步长为2，不包括10print('示例结果：',list(range(1,10,2)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">示例结果： [1, 3, 5, 7, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">#range(10,0,-1)指的是10开始，步长为-1，不包括0print('示例结果：',list(range(10,0,-1)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">示例结果： [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>range类型的优点</strong><br>不管range对象表示的整数序列有多长，所有range对象占用的内存空间都是相同的，因为仅仅需要储存start,stop,step，只有当用到range对象时，才会去计算序列中的相关元素</p><p><strong>python中数组的del,remove,pop</strong></p><pre class="line-numbers language-sh"><code class="language-sh">#remove()删除首个符合条件的元素，并非特定的索引remove_array=['a','b','b','c']print('remove()的返回值',remove_array.remove('b'))print('remove()操作后数组的长度',len(remove_array))print('remove()操作后数组的内容',list(remove_array))#pop返回的是你弹出的那个元素，参数为索引pop_array=['a','b','c']print('pop()的返回值',pop_array.pop(1))print('pop()操作后数组的长度',len(pop_array))print('pop()操作后数组的内容',list(pop_array))#del它是根据索引也就是元素所在位置来删除del_array=['a','b','c']del del_array[1]print('del()操作后数组的长度',len(del_array))print('del()操作后数组的内容',list(del_array))  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">remove()的返回值 Noneremove()操作后数组的长度 3remove()操作后数组的内容 ['a', 'b', 'c']pop()的返回值 bpop()操作后数组的长度 2pop()操作后数组的内容 ['a', 'c']del()操作后数组的长度 2del()操作后数组的内容 ['a', 'c']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Solution </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL固定分组统计</title>
      <link href="/2020/02/20/mysql/"/>
      <url>/2020/02/20/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em>不不要在夕阳西下时幻想，要在旭日东升时努力。</em></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>统计每个订单各个规格的饮料销售数量以及总数.</p><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>goods表</p><pre class="line-numbers language-sh"><code class="language-sh">+----+----------+-------------+------+| id | good_sku | good_name   | size |+----+----------+-------------+------+|  1 | C2019001 | 可乐-0.5L   | 0.5L ||  2 | C2019002 | 可乐-1.5L   | 1.5L ||  3 | C2019003 | 可乐-2L     | 2L   |+----+----------+-------------+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>orders表</p><pre class="line-numbers language-sh"><code class="language-sh">+----+--------------+--------+| id | order_num    | remark |+----+--------------+--------+|  1 | 20190220-001 | NULL   ||  2 | 20190220-002 | NULL   ||  3 | 20190220-003 | NULL   ||  4 | 20190220-004 | NULL   ||  5 | 20190220-005 | NULL   |+----+--------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>order_item表</p><pre class="line-numbers language-sh"><code class="language-sh">+----+----------+----------+-------------+------+| id | order_id | good_sku | good_name   | num  |+----+----------+----------+-------------+------+|  1 |        1 | C2019001 | 可乐-0.5L   |    1 ||  2 |        1 | C2019002 | 可乐-1.5L   |    1 ||  3 |        2 | C2019001 | 可乐-0.5L   |    2 ||  4 |        2 | C2019002 | 可乐-1.5L   |    1 ||  5 |        3 | C2019001 | 可乐-0.5L   |    4 ||  6 |        3 | C2019002 | 可乐-1.5L   |    2 ||  7 |        3 | C2019003 | 可乐-2L     |    1 ||  8 |        4 | C2019003 | 可乐-2L     |    2 ||  9 |        5 | C2019001 | 可乐-0.5L   |    2 || 10 |        5 | C2019002 | 可乐-1.5L   |    2 || 11 |        5 | C2019003 | 可乐-2L     |    1 |+----+----------+----------+-------------+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><pre class="line-numbers language-sh"><code class="language-sh">SELECT    o.*,    sum(        CASE WHEN g.size = '0.5L' THEN            i.num        ELSE            0        END) AS '0.5L',    sum(        CASE WHEN g.size = '1.5L' THEN            i.num        ELSE            0        END) AS '1.5L',    sum(        CASE WHEN g.size = '2L' THEN            i.num        ELSE            0        END) AS '2L',    sum(i.num) AS tol_numFROM    orders o    LEFT JOIN order_item i ON o.id = i.order_id    LEFT JOIN goods g ON i.good_sku = g.good_skuGROUP BY    o.id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SQL查询结果"><a href="#SQL查询结果" class="headerlink" title="SQL查询结果"></a>SQL查询结果</h2><pre class="line-numbers language-sh"><code class="language-sh">+----+--------------+--------+------+------+------+---------+| id | order_num    | remark | 0.5L | 1.5L | 2L   | tol_num |+----+--------------+--------+------+------+------+---------+|  1 | 20190220-001 | NULL   |    1 |    1 |    0 |       2 ||  2 | 20190220-002 | NULL   |    2 |    1 |    0 |       3 ||  3 | 20190220-003 | NULL   |    4 |    2 |    1 |       7 ||  4 | 20190220-004 | NULL   |    0 |    0 |    2 |       2 ||  5 | 20190220-005 | NULL   |    2 |    2 |    1 |       5 |+----+--------------+--------+------+------+------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 与 Shell</title>
      <link href="/2020/02/18/article-title/"/>
      <url>/2020/02/18/article-title/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络安全</p><h2 id="操作系统简史"><a href="#操作系统简史" class="headerlink" title="操作系统简史"></a>操作系统简史</h2><p>操作系统可分为四个时代<br>第一个时代是OS时代，这个时候操作系统才刚刚成型，最早是1973年由贝尔实验室开发的UNIX系统，以及1982年与1991年在UNIX系统基础上进行扩展定制的若干变种<br>第二个时代是PC时代，PC时代崛起于1975年，当年乔布斯开发了Apple系统，随后1980年，比尔盖茨开发了DOS系统，从这时起更多的人开始接触操作系统，个人计算机得以普及。<br>第三个时代是GUI时代，GUI时代的代表作是1979年乔布斯开发的Mac系统与1990年比尔盖茨开发的Windows系统，以及1994年的Linux系统，这三个系统影响了整个时代，一直到现在仍被广泛使用。<br>第四个时代是移动OS时代，随着移动互联网的发展，移动OS也变得越来越重要，在移动OS时代，最知名的是Google的Android系统，以及乔布斯的iOS系统。</p><h2 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h2><p><img src="shuoming.jpeg" alt="shuoming"></p><h2 id="Bash是什么"><a href="#Bash是什么" class="headerlink" title="Bash是什么"></a>Bash是什么</h2><p><strong>百度一下</strong><br><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 与 Shell</title>
      <link href="/2020/02/18/article-linux/"/>
      <url>/2020/02/18/article-linux/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em>不渴望能够一跃千里，只希望每天能够前进一步。</em></p><h2 id="操作系统简史"><a href="#操作系统简史" class="headerlink" title="操作系统简史"></a>操作系统简史</h2><p>四个时代<br>第一个时代是OS时代，这个时候操作系统才刚刚成型，最早是1973年由贝尔实验室开发的UNIX系统，以及1982年与1991年在UNIX系统基础上进行扩展定制的若干变种。<br>第二个时代是PC时代，PC时代崛起于1975年，当年乔布斯开发了Apple系统，随后1980年，比尔盖茨开发了DOS系统，从这时起更多的人开始接触操作系统，个人计算机得以普及。<br>第三个时代是GUI时代，GUI时代的代表作是1979年乔布斯开发的Mac系统与1990年比尔盖茨开发的Windows系统，以及1994年的Linux系统，这三个系统影响了整个时代，一直到现在仍被广泛使用。<br>第四个时代是移动OS时代，随着移动互联网的发展，移动OS也变得越来越重要，在移动OS时代，最知名的是Google的Android系统，以及乔布斯的iOS系统。</p><h2 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h2><p><img src="Linux.png" alt="Linux"><br>Shell是用户与内核交互操作的接口，它接收用户的命令然后传递给内核，内核执行命令并将执行结果通过Shell返回给用户。<br>Shell既是一种命令解释器，也是一种编程语言。Shell有很多种版本，主要的版本如下：<br>Bourne Shell，源于UNIX早期版本的Shell。<br>Bash，又名Bourne Again Shell，来自GUN项目，它是Linux主要的Shell。<br>Korn Shell，它是对Bourne Shell的发展。<br>C shell，是SUN公司Shell的BSD版本。</p><h2 id="Bash是什么"><a href="#Bash是什么" class="headerlink" title="Bash是什么"></a>Bash是什么</h2><p>Bash是Shell的一种，在Linux中常用的Shell就是Bourne-Again shell（简称bash）。<br>Bash有很灵活和强大的编程接口，同时又有很友好的用户界面。</p><p><strong>Bash的特点：</strong> </p><p><strong>•命令历史、命令补全</strong><br><strong>•管道、重定向</strong><br><strong>•命令别名</strong><br><strong>•命令行编辑</strong><br><strong>•命令行展开</strong><br><strong>•文件名通配</strong><br><strong>•变量</strong><br><strong>•编程</strong></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="文件系统管理命令"><a href="#文件系统管理命令" class="headerlink" title="文件系统管理命令"></a>文件系统管理命令</h3><p>对文件及目录的管理操作包括新建、浏览、编辑、修改、删除等。</p><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p>ls命令：显示文件信息命令</p><p>功能：ls命令显示关于文件的信息，其中的文件包括任何类型的文件和目录。</p><p>用法1：<code>ls</code></p><pre><code>[root@TheAnswer test]# lsa  a.txt</code></pre><p>test文件夹下使用ls命令可以看到有一个a文件夹和一个a.txt文件</p><p>用法2：<code>ls -l</code><br>该命令显示文件或者目录下的文件的详细信息，包括文件类型及权限、连接数、文件所有者及所有者所属的组、文件大小、访问日期、时间、名称。</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer test]# ls -l总用量 8drwxr-xr-x 3 root root 4096 2月  11 20:36 a-rw-r--r-- 1 root root   14 2月  11 20:43 a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>小提示：每一列的含义<br><img src="lsjieshitu.png" alt="Linux"></p><p><strong>”标号1“：</strong></p><table><thead><tr><th align="center">-</th><th align="center">d</th><th align="center">p</th><th align="center">l</th><th align="center">b</th><th align="center">c</th><th align="center">s</th></tr></thead><tbody><tr><td align="center">普通文件</td><td align="center">目录文件</td><td align="center">管理文件</td><td align="center">链接文件</td><td align="center">块设备文件</td><td align="center">字符设备文件</td><td align="center">套接字文件</td></tr></tbody></table><p><strong>”标号2“：</strong>所有者/所有者权限</p><p><strong>”标号3“：</strong>组用户权限（一个组中除所有者拥有的权限）</p><p><strong>”标号4“：</strong>其他用户权限（除当前所有者的组，其他组的权限）</p><p><strong>文件权限</strong></p><table><thead><tr><th align="center">r</th><th align="center">w</th><th align="center">x</th><th align="center">-</th></tr></thead><tbody><tr><td align="center">读权限</td><td align="center">写权限</td><td align="center">可执行权限</td><td align="center">无权限</td></tr></tbody></table><p><strong>”标号5“：</strong>如果是普通文件则为连接数,如果是目录文件则为第一级子目录数</p><p><strong>”标号6“：</strong>用户名</p><p><strong>”标号7“：</strong>组名</p><p><strong>”标号8“：</strong>表示文件大小，单位为字节</p><p><strong>”标号9“：</strong>表示最后修改时间</p><p><strong>”标号10“：</strong>文件名</p><p><strong>”标号11“：</strong>文件后缀</p><p>用法3：<code>ls -l [文件包含的字符]*</code></p><p>test目录下文件如下 a，a123，a.txt，bcd，下面使用ls -l a* 这个命令。</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer test]# ls -l总用量 16drwxr-xr-x 3 root root 4096 2月  11 20:36 adrwxr-xr-x 2 root root 4096 2月  11 18:05 a123-rw-r--r-- 1 root root   14 2月  11 17:43 a.txtdrwxr-xr-x 2 root root 4096 2月  11 18:05 bcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ls -l a* 该命令是显示当前目录下以a开头的文件或目录的详细信息。*是文件名称的匹配符，表示可以匹配任意字符串。</p><pre><code>[root@TheAnswer test]# ls -l a*-rw-r--r-- 1 root root   14 2月  11 17:43 a.txta:总用量 4drwxr-xr-x 3 root root 4096 2月  11 20:39 ba123:总用量 0</code></pre><p>用法4：<code>ls -a 、ls -al</code><br>ls -a 会把隐藏文件显示出来，如果要想看到文件的信息的话就可以使用 ls -al。</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer test]# ls -a.  ..  a  a123  .abc.txt  a.txt  bcd[root@TheAnswer test]# ls -al总用量 24drwxr-xr-x  5 root root 4096 2月  11 18:31 .dr-xr-x---. 8 root root 4096 2月  11 17:12 ..drwxr-xr-x  3 root root 4096 2月  11 20:36 adrwxr-xr-x  2 root root 4096 2月  11 18:05 a123-rw-r--r--  1 root root    0 2月  11 18:31 .abc.txt-rw-r--r--  1 root root   14 2月  11 17:43 a.txtdrwxr-xr-x  2 root root 4096 2月  11 18:05 bcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p>pwd命令：显示用户当前工作目录，</p><p>功能：显示当前目录在文件系统层次中的位置。</p><p>用法：<code>pwd</code></p><p>先进入到一个工作目录下</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer ~]# cd test/a[root@TheAnswer a]#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后输入pwd</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer ~]# cd test/a[root@TheAnswer a]#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer a]# pwd/root/test/a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="目录管理命令-mkdir-rmdir"><a href="#目录管理命令-mkdir-rmdir" class="headerlink" title="目录管理命令-mkdir/rmdir"></a>目录管理命令-mkdir/rmdir</h4><p>语法：<br>mkdir[参数] 目录名称<br>rmdir[参数] 目录名称</p><p>功能：创建目录和删除目录。mkdir命令表示在当前目录中建立一个新目录，rmdir表示删除指定的目录。<br>-p表示递归删除或者创建目录。</p><p>用法：<code>mkdir/rmdir -p 目录</code></p><p>当前目录创建目录/删除目录</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer ~]# cd test/a[root@TheAnswer a]#[root@TheAnswer test]# lsa  a123  a.txt  bcd[root@TheAnswer test]# mkdir test1[root@TheAnswer test]# lsa  a123  a.txt  bcd  test1[root@TheAnswer test]# rmdir test1[root@TheAnswer test]# lsa  a123  a.txt  bcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归创建/删除目录</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer test]# mkdir -p test1/test2/test3[root@TheAnswer test]# cd test1/test2/test3[root@TheAnswer test3]# pwd/root/test/test1/test2/test3[root@TheAnswer test]# rmdir -p test1/test2/test3[root@TheAnswer test]# lsa  a123  a.txt  bcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除文件工具-rm"><a href="#删除文件工具-rm" class="headerlink" title="删除文件工具-rm"></a>删除文件工具-rm</h4><p>语法：<br>rm[参数] file1 file2 ……<br>rm[参数] dir1 dir2 dir ……</p><p>功能：rm用来删除一个或多个文件的工具。并且可以用于删除非空目录。<br>也可以使用参数<code>-rf</code>强制删除一个非空目录。</p><p>参数：<br><code>-f</code> 表示不显示警告或提示直接删除。<br><code>-i</code> 表示删除文件时显示警告信息并提示是否删除。<br><code>-r</code>或<code>-R</code>表示可以递归删除整个目录包括子目录及目录下的所有文件。</p><p>用法：<code>rm -i file</code></p><p>删除文件</p><p>先用<code>touch b.txt </code>创建一个文件</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer test]# touch b.txt[root@TheAnswer test]# lsa  a123  a.txt  bcd  b.txt[root@TheAnswer test]# rm -i b.txtrm：是否删除普通空文件 "b.txt"？y[root@TheAnswer test]# lsa  a123  a.txt  bcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用法：<code>rm -ir dir</code></p><p>删除目录及所有下级目录和文件</p><p>先用<code>touch b.txt </code>创建一个文件</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer test]# lsa  a123  a.txt  bcd[root@TheAnswer test]# rmdir armdir: 删除 "a" 失败: 目录非空[root@TheAnswer test]# rm -ir arm：是否进入目录"a"? yrm：是否进入目录"a/b"? yrm：是否进入目录"a/b/c"? yrm：是否进入目录"a/b/c/d"? yrm：是否进入目录"a/b/c/d/e"? yrm：是否删除普通空文件 "a/b/c/d/e/e.txt"？yrm：是否删除目录 "a/b/c/d/e"？yrm：是否删除目录 "a/b/c/d"？yrm：是否删除目录 "a/b/c"？yrm：是否删除目录 "a/b"？yrm：是否删除目录 "a"？y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用法：<code>rm -rf dir</code></p><p>不需要提示删除目录及所有下级目录和文件</p><h4 id="文件名修改命令-mv"><a href="#文件名修改命令-mv" class="headerlink" title="文件名修改命令-mv"></a>文件名修改命令-mv</h4><p>语法：<br>mv 原文件名或目录名新文件名或目录名</p><p>功能：文件更名或搬移。</p><p>用法：<code>mv filename1 filename2</code></p><p>将名称为filename1的文件改名为filename2并删除原文件。</p><pre class="line-numbers language-sh"><code class="language-sh">[root@TheAnswer test]# lsa123  a.txt  bcd[root@TheAnswer test]# mv a.txt abcd.txt[root@TheAnswer test]# lsa123  abcd.txt  bcd[root@TheAnswer test]#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用法：<code>mv filename1 path/filename2</code></p><p>将名称为filename1的文件移动到path路径下并改名为filename2并删除原文件。</p><pre class="line-numbers language-sh"><code class="language-sh">[root@izbp14yziiuvu2qh2n015xz test]# lsa123  a.txt  bcd[root@izbp14yziiuvu2qh2n015xz test]# mv a.txt abcd.txt[root@izbp14yziiuvu2qh2n015xz test]# lsa123  abcd.txt  bcd[root@izbp14yziiuvu2qh2n015xz test]# lsa123  abcd.txt  bcd[root@izbp14yziiuvu2qh2n015xz test]# mv abcd.txt bcd/bcd.txt[root@izbp14yziiuvu2qh2n015xz test]# lsa123  bcd[root@izbp14yziiuvu2qh2n015xz test]# cd bcd[root@izbp14yziiuvu2qh2n015xz bcd]# lsbcd.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><table><thead><tr><th align="center">-eq</th><th align="center">-ne</th><th align="center">-gt</th><th align="center">-lt</th><th align="center">ge</th><th align="center">le</th></tr></thead><tbody><tr><td align="center">等于</td><td align="center">不等于</td><td align="center">大于</td><td align="center">小于</td><td align="center">大于等于</td><td align="center">小于等于</td></tr></tbody></table><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h4><p><code>[function] name(){函数体}[重定向]</code><br>其中function关键字和重定向是可选的</p><h4 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h4><p><code>name 参数列表</code></p><h4 id="写一个max函数返回3个参数中的最大值"><a href="#写一个max函数返回3个参数中的最大值" class="headerlink" title="写一个max函数返回3个参数中的最大值"></a>写一个max函数返回3个参数中的最大值</h4><pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bashfunction max( ){echo $# $1 $2 $3if [ $# -ne 3 ];thenecho "usage:max p1 p2 p3"exit 1fimax=$1if [ max -lt $2 ];thenmax=$2fiif [ max -lt $3 ];thenmax=$3fireturn max}max 1 2 3echo "the max number of 1 2 3 is : $?"exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上面程序报错</p><pre class="line-numbers language-sh"><code class="language-sh">./max.sh: 第 11 行:[: max: 期待整数表达式./max.sh: 第 14 行:[: max: 期待整数表达式./max.sh: 第 17 行:return: max: 需要数字参数the max number of 1 2 3 is : 255<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可能是max 有歧义 用 ${max} 或者 $max 代替max成功了</p><pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bashfunction max( ){echo $# $1 $2 $3if [ $# -ne 3 ];thenecho "usage:max p1 p2 p3"exit 1fimax=$1if [ ${max} -lt $2 ];thenmax=$2fiif [ ${max} -lt $3 ];thenmax=$3fireturn ${max}}max 1 2 3echo "the max number of 1 2 3 is : $?"exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-sh"><code class="language-sh">the max number of 1 2 3 is : 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id><a href="#" class="headerlink" title="$?"></a>$?</h3><h4 id="获取上一个命令的退出状态"><a href="#获取上一个命令的退出状态" class="headerlink" title="获取上一个命令的退出状态"></a>获取上一个命令的退出状态</h4><pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bashfunction max( ){if [ $# -ne 3 ];thenecho "usage:max p1 p2 p3"exit 1fimax=$1if [ $max -lt $2 ];thenmax=$2fiif [ ${max} -lt $3 ];thenmax=$3fireturn ${max}}max 1 2 28 4echo "the max number is : $?"exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>max.sh中max方法传进去4个参数，这个时候会退出脚本且状态为1</p><pre class="line-numbers language-sh"><code class="language-sh">[root@izbp14yziiuvu2qh2n015xz test]# echo $?1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取函数的返回值"><a href="#获取函数的返回值" class="headerlink" title="获取函数的返回值"></a>获取函数的返回值</h4><pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bashfunction max( ){if [ $# -ne 3 ];thenecho "usage:max p1 p2 p3"exit 1fimax=$1if [ $max -lt $2 ];thenmax=$2fiif [ ${max} -lt $3 ];thenmax=$3fireturn ${max}}max 1 2 28 echo "the max number is : $?"exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-sh"><code class="language-sh">the max number is : 28<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把最大值得参数改为255</p><p>结果</p><pre class="line-numbers language-sh"><code class="language-sh">the max number is : 255<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把最大值得参数改为256</p><pre class="line-numbers language-sh"><code class="language-sh">the max number is : 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个是后$？获取值是0</p><p>$?获取的返回值是0~255之前，超过255开始从0计算 也就是说 256 输出 0，257输出1，258输出2</p><p>怎么获取返回值？</p><p>用全局变量来获取</p><p><code>$max</code></p><p>注：在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果</p><p><strong>百度一下</strong><br><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全</title>
      <link href="/2020/02/16/wenzhangmoban/"/>
      <url>/2020/02/16/wenzhangmoban/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络安全</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><p>网络安全<br><strong>百度一下</strong><br><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
